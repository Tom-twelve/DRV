/**
 ******************************************************************************
 * @file		svpwm.c
 * @author		WrathWings
 * @version 	V1.0
 * @date		2018.1.17
 * @brief		Algorithm of SVPWM
 ******************************************************************************
 * @attention
 *
 ******************************************************************************
 */
 
 /* Private includes ----------------------------------------------------------*/
/* CODE BEGIN Includes */
#include "svpwm.h"
/* CODE END Includes */

/* Private typedef -----------------------------------------------------------*/
/* CODE BEGIN PTD */

/* CODE END PTD */

/* Private variables ---------------------------------------------------------*/
/* CODE BEGIN PV */
float		FrequencyRatio = 0;
float		ModulationCoefficient = 0;
float		VoltageVectorRadianIncrement = 0;
float		VoltageVectorAngleIncrement = 0;
float		ModulationAngle = 0;
float		ActuationDuration_0 = 0;
float		ActuationDuration_1 = 0;
float		ActuationDuration_2 = 0;
float		ActuationDuration_3 = 0;
float		ActuationDuration_4 = 0;
float		ActuationDuration_5 = 0;
float		ActuationDuration_6 = 0;
float		ActuationDuration_7 = 0;
float		DutyRatio_PhaseA = 0;
float		DutyRatio_PhaseB = 0;
float		DutyRatio_PhaseC = 0;

const float	sqrt3 = 1.732050f;
const float sine[361] = 
{
0.000000f,
0.017452f,
0.034899f,
0.052336f,
0.069756f,
0.087156f,
0.104528f,
0.121869f,
0.139173f,
0.156434f,
0.173648f,
0.190809f,
0.207912f,
0.224951f,
0.241922f,
0.258819f,
0.275637f,
0.292372f,
0.309017f,
0.325568f,
0.342020f,
0.358368f,
0.374607f,
0.390731f,
0.406737f,
0.422618f,
0.438371f,
0.453990f,
0.469472f,
0.484810f,
0.500000f,
0.515038f,
0.529919f,
0.544639f,
0.559193f,
0.573576f,
0.587785f,
0.601815f,
0.615661f,
0.629320f,
0.642788f,
0.656059f,
0.669131f,
0.681998f,
0.694658f,
0.707107f,
0.719340f,
0.731354f,
0.743145f,
0.754710f,
0.766044f,
0.777146f,
0.788011f,
0.798636f,
0.809017f,
0.819152f,
0.829038f,
0.838671f,
0.848048f,
0.857167f,
0.866025f,
0.874620f,
0.882948f,
0.891007f,
0.898794f,
0.906308f,
0.913545f,
0.920505f,
0.927184f,
0.933580f,
0.939693f,
0.945519f,
0.951057f,
0.956305f,
0.961262f,
0.965926f,
0.970296f,
0.974370f,
0.978148f,
0.981627f,
0.984808f,
0.987688f,
0.990268f,
0.992546f,
0.994522f,
0.996195f,
0.997564f,
0.998630f,
0.999391f,
0.999848f,
1.000000f,
0.999848f,
0.999391f,
0.998630f,
0.997564f,
0.996195f,
0.994522f,
0.992546f,
0.990268f,
0.987688f,
0.984808f,
0.981627f,
0.978148f,
0.974370f,
0.970296f,
0.965926f,
0.961262f,
0.956305f,
0.951057f,
0.945519f,
0.939693f,
0.933580f,
0.927184f,
0.920505f,
0.913545f,
0.906308f,
0.898794f,
0.891007f,
0.882948f,
0.874620f,
0.866025f,
0.857167f,
0.848048f,
0.838671f,
0.829038f,
0.819152f,
0.809017f,
0.798636f,
0.788011f, 
0.777146f, 
0.766044f,
0.754710f,
0.743145f,
0.731354f,
0.719340f,
0.707107f,
0.694658f,
0.681998f,
0.669131f,
0.656059f,
0.642788f,
0.629320f,
0.615661f,
0.601815f,
0.587785f,
0.573576f,
0.559193f,
0.544639f,
0.529919f,
0.515038f,
0.500000f,
0.484810f,
0.469472f,
0.453990f,
0.438371f,
0.422618f,
0.406737f,
0.390731f,
0.374607f,
0.358368f,
0.342020f,
0.325568f,
0.309017f,
0.292372f,
0.275637f,
0.258819f,
0.241922f,
0.224951f,
0.207912f,
0.190809f,
0.173648f,
0.156434f,
0.139173f,
0.121869f,
0.104528f,
0.087156f,
0.069756f,
0.052336f,
0.034899f,
0.017452f,
0.000000f,
-0.017452f,
-0.034899f,
-0.052336f,
-0.069756f,
-0.087156f,
-0.104528f,
-0.121869f,
-0.139173f,
-0.156434f,
-0.173648f,
-0.190809f,
-0.207912f,
-0.224951f,
-0.241922f,
-0.258819f,
-0.275637f,
-0.292372f,
-0.309017f,
-0.325568f,
-0.342020f,
-0.358368f,
-0.374607f,
-0.390731f,
-0.406737f,
-0.422618f,
-0.438371f,
-0.453990f,
-0.469472f,
-0.484810f,
-0.500000f,
-0.515038f,
-0.529919f,
-0.544639f,
-0.559193f,
-0.573576f,
-0.587785f
-0.601815f,
-0.615661f,
-0.629320f,
-0.642788f,
-0.656059f,
-0.669131f,
-0.681998f,
-0.694658f,
-0.707107f,
-0.719340f,
-0.731354f,
-0.743145f,
-0.754710f,
-0.766044f,
-0.777146f,
-0.788011f,
-0.798636f,
-0.809017f,
-0.819152f,
-0.829038f,
-0.838671f,
-0.848048f,
-0.857167f,
-0.866025f,
-0.874620f,
-0.882948f,
-0.891007f,
-0.898794f,
-0.906308f,
-0.913545f,
-0.920505f,
-0.927184f,
-0.933580f,
-0.939693f,
-0.945519f,
-0.951057f,
-0.956305f,
-0.961262f,
-0.965926f,
-0.970296f,
-0.974370f,
-0.978148f,
-0.981627f,
-0.984808f,
-0.987688f,
-0.990268f,
-0.992546f,
-0.994522f,
-0.996195f,
-0.997564f,
-0.998630f,
-0.999391f,
-0.999848f,
-1.000000f,
-0.999848f,
-0.999391f,
-0.998630f,
-0.997564f,
-0.996195f,
-0.994522f,
-0.992546f,
-0.990268f,
-0.987688f,
-0.984808f,
-0.981627f,
-0.978148f,
-0.974370f,
-0.970296f,
-0.965926f,
-0.961262f,
-0.956305f,
-0.951057f,
-0.945519f,
-0.939693f,
-0.933580f,
-0.927184f,
-0.920505f,
-0.913545f,
-0.906308f,
-0.898794f,
-0.891007f,
-0.882948f,
-0.874620f,
-0.866025f,
-0.857167f,
-0.848048f,
-0.838671f,
-0.829038f,
-0.819152f,
-0.809017f,
-0.798636f,
-0.788011f,
-0.777146f,
-0.766044f,
-0.754710f,
-0.743145f,
-0.731354f,
-0.719340f,
-0.707107f,
-0.694658f,
-0.681998f,
-0.669131f,
-0.656059f,
-0.642788f,
-0.629320f,
-0.615661f,
-0.601815f,
-0.587785f,
-0.573576f,
-0.559193f,
-0.544639f,
-0.529919f,
-0.515038f,
-0.500000f,
-0.484810f,
-0.469472f,
-0.453990f,
-0.438371f,
-0.422618f,
-0.406737f,
-0.390731f,
-0.374607f,
-0.358368f,
-0.342020f,
-0.325568f,
-0.309017f,
-0.292372f,
-0.275637f,
-0.258819f,
-0.241922f,
-0.224951f,
-0.207912f,
-0.190809f,
-0.173648f,
-0.156434f,
-0.139173f,
-0.121869f,
-0.104528f,
-0.087156f,
-0.069756f,
-0.052336f,
-0.034899f,
-0.017452f,
0.000000f
};

/* CODE END PV */

/* External variables --------------------------------------------------------*/
/* USER CODE BEGIN EV */

/* USER CODE END EV */

/* USER CODE BEGIN */

void SpaceVectorPulseWidthModulation(float voltageAlpha, float voltageBeta, float electricalAngle)
{
	uint8_t sectionNum = 0;
	uint8_t sectionFlag = 0;
	uint8_t A = 0;
	uint8_t B = 0;
	uint8_t C = 0;
	float U1 = 0;
	float U2 = 0;
	float U3 = 0;
	
	/*	判断Uref所在扇区	*/
	U1 = voltageBeta;
	U2 = sqrt3 * voltageAlpha / 2 - voltageBeta / 2;
	U3 = - sqrt3 * voltageAlpha / 2 - voltageBeta / 2;
	
	if(U1 > 0)
	{
		A = 1;
	}
	else
	{
		A = 0;
	}
	if(U2 > 0)
	{
		B = 1;
	}
	else
	{
		B = 0;
	}
	if(U3 > 0)
	{
		C = 1;
	}
	else
	{
		C = 0;
	}
	
	sectionFlag = 4*C + 2*B + A;
	
	switch(sectionFlag)
	{
		case 3:	sectionNum = 1;
		break;
		case 1:	sectionNum = 2;
		break;
		case 5:	sectionNum = 3;
		break;
		case 4:	sectionNum = 4;
		break;
		case 6:	sectionNum = 5;
		break;
		case 2:	sectionNum = 6;
		break;
	}
	
	/*	计算基本矢量作用时间	*/
	switch(sectionNum)
	{
		case 1: ActuationDuration_4 = sqrt3 * CarrierPeriod * U2 / GeneratrixVoltage;
				ActuationDuration_6 = sqrt3 * CarrierPeriod * U1 / GeneratrixVoltage;
				ActuationDuration_7 = (CarrierPeriod - ActuationDuration_4 - ActuationDuration_6) / 2;
				ActuationDuration_0 = ActuationDuration_7;
				
				#if	PhaseSequence == PositivePhase
				DutyRatio_PhaseA = (ActuationDuration_4 + ActuationDuration_6 + ActuationDuration_7) * CarrierFrequency;
				DutyRatio_PhaseB = (ActuationDuration_6 + ActuationDuration_7) * CarrierFrequency;
				DutyRatio_PhaseC = ActuationDuration_7 * CarrierFrequency;
				#elif	PhaseSequence == NegativePhase
				DutyRatio_PhaseA = (ActuationDuration_4 + ActuationDuration_6 + ActuationDuration_7) * CarrierFrequency;
				DutyRatio_PhaseB = (ActuationDuration_6 + ActuationDuration_7) * CarrierFrequency;
				DutyRatio_PhaseC = ActuationDuration_7 * CarrierFrequency;
				#else
				#error "Phase Sequence Invalid"
				#endif
				SetDutyRatio_PhaseA(DutyRatio_PhaseA);
				SetDutyRatio_PhaseB(DutyRatio_PhaseB);
				SetDutyRatio_PhaseC(DutyRatio_PhaseC);
		break;
		case 2: ActuationDuration_2 = sqrt3 * CarrierPeriod * U2 / GeneratrixVoltage;
				ActuationDuration_6 = sqrt3 * CarrierPeriod * U3 / GeneratrixVoltage;
				ActuationDuration_7 = (CarrierPeriod - ActuationDuration_2 - ActuationDuration_6) / 2;
				ActuationDuration_0 = ActuationDuration_7;
				
				#if	PhaseSequence == PositivePhase
				DutyRatio_PhaseA = (ActuationDuration_6 + ActuationDuration_7) * CarrierFrequency;
				DutyRatio_PhaseB = (ActuationDuration_2 + ActuationDuration_6 + ActuationDuration_7) * CarrierFrequency;
				DutyRatio_PhaseC =	ActuationDuration_7 * CarrierFrequency;
				#elif	PhaseSequence == NegativePhase
				DutyRatio_PhaseA =	ActuationDuration_7 * CarrierFrequency;
				DutyRatio_PhaseB = (ActuationDuration_2 + ActuationDuration_6 + ActuationDuration_7) * CarrierFrequency;
				DutyRatio_PhaseC = (ActuationDuration_6 + ActuationDuration_7) * CarrierFrequency;
				#else
				#error "Phase Sequence Invalid"
				#endif
				SetDutyRatio_PhaseA(DutyRatio_PhaseA);
				SetDutyRatio_PhaseB(DutyRatio_PhaseB);
				SetDutyRatio_PhaseC(DutyRatio_PhaseC);
		break;
		case 3: ActuationDuration_2 = sqrt3 * CarrierPeriod * U1 / GeneratrixVoltage;
				ActuationDuration_3 = sqrt3 * CarrierPeriod * U3 / GeneratrixVoltage;
				ActuationDuration_7 = (CarrierPeriod - ActuationDuration_2 - ActuationDuration_3) / 2;
				ActuationDuration_0 = ActuationDuration_7;
				
				#if	PhaseSequence == PositivePhase
				DutyRatio_PhaseA =	ActuationDuration_7 * CarrierFrequency;
				DutyRatio_PhaseB = (ActuationDuration_2 + ActuationDuration_3 + ActuationDuration_7) * CarrierFrequency;
				DutyRatio_PhaseC = (ActuationDuration_3 + ActuationDuration_7) * CarrierFrequency;
				#elif	PhaseSequence == NegativePhase
				DutyRatio_PhaseA = (ActuationDuration_3 + ActuationDuration_7) * CarrierFrequency;
				DutyRatio_PhaseB = (ActuationDuration_2 + ActuationDuration_3 + ActuationDuration_7) * CarrierFrequency;
				DutyRatio_PhaseC =	ActuationDuration_7 * CarrierFrequency;
				#else
				#error "Phase Sequence Invalid"
				#endif
				SetDutyRatio_PhaseA(DutyRatio_PhaseA);
				SetDutyRatio_PhaseB(DutyRatio_PhaseB);
				SetDutyRatio_PhaseC(DutyRatio_PhaseC);
		break;
		case 4: ActuationDuration_1 = sqrt3 * CarrierPeriod * U1 / GeneratrixVoltage;
				ActuationDuration_3 = sqrt3 * CarrierPeriod * U2 / GeneratrixVoltage;
				ActuationDuration_7 = (CarrierPeriod - ActuationDuration_1 - ActuationDuration_3) / 2;
				ActuationDuration_0 = ActuationDuration_7;
				
				#if	PhaseSequence == PositivePhase
				DutyRatio_PhaseA =	ActuationDuration_7 * CarrierFrequency;
				DutyRatio_PhaseB = (ActuationDuration_3 + ActuationDuration_7) * CarrierFrequency;
				DutyRatio_PhaseC = (ActuationDuration_1 + ActuationDuration_3 + ActuationDuration_7) * CarrierFrequency;
				#elif	PhaseSequence == NegativePhase
				DutyRatio_PhaseA = (ActuationDuration_1 + ActuationDuration_3 + ActuationDuration_7) * CarrierFrequency;
				DutyRatio_PhaseB = (ActuationDuration_3 + ActuationDuration_7) * CarrierFrequency;
				DutyRatio_PhaseC =	ActuationDuration_7 * CarrierFrequency;
				#else
				#error "Phase Sequence Invalid"
				#endif
				SetDutyRatio_PhaseA(DutyRatio_PhaseA);
				SetDutyRatio_PhaseB(DutyRatio_PhaseB);
				SetDutyRatio_PhaseC(DutyRatio_PhaseC);
		break;
		case 5: ActuationDuration_1 = sqrt3 * CarrierPeriod * U3 / GeneratrixVoltage;
				ActuationDuration_5 = sqrt3 * CarrierPeriod * U2 / GeneratrixVoltage;
				ActuationDuration_7 = (CarrierPeriod - ActuationDuration_1 - ActuationDuration_5) / 2;
				ActuationDuration_0 = ActuationDuration_7;
				
				#if	PhaseSequence == PositivePhase
				DutyRatio_PhaseA = (ActuationDuration_5 + ActuationDuration_7) * CarrierFrequency;
				DutyRatio_PhaseB =	ActuationDuration_7 * CarrierFrequency;
				DutyRatio_PhaseC = (ActuationDuration_1 + ActuationDuration_5 + ActuationDuration_7) * CarrierFrequency;
				#elif	PhaseSequence == NegativePhase
				DutyRatio_PhaseA = (ActuationDuration_1 + ActuationDuration_5 + ActuationDuration_7) * CarrierFrequency;
				DutyRatio_PhaseB =	ActuationDuration_7 * CarrierFrequency;
				DutyRatio_PhaseC = (ActuationDuration_5 + ActuationDuration_7) * CarrierFrequency;
				#else
				#error "Phase Sequence Invalid"
				#endif
				SetDutyRatio_PhaseA(DutyRatio_PhaseA);
				SetDutyRatio_PhaseB(DutyRatio_PhaseB);
				SetDutyRatio_PhaseC(DutyRatio_PhaseC);
		break;
		case 6: ActuationDuration_4 = sqrt3 * CarrierPeriod * U3 / GeneratrixVoltage;
				ActuationDuration_5 = sqrt3 * CarrierPeriod * U1 / GeneratrixVoltage;
				ActuationDuration_7 = (CarrierPeriod - ActuationDuration_4 - ActuationDuration_5) / 2;
				ActuationDuration_0 = ActuationDuration_7;
				
				#if	PhaseSequence == PositivePhase
				DutyRatio_PhaseA = (ActuationDuration_4 + ActuationDuration_5 + ActuationDuration_7) * CarrierFrequency;
				DutyRatio_PhaseB =	ActuationDuration_7 * CarrierFrequency;
				DutyRatio_PhaseC = (ActuationDuration_5 + ActuationDuration_7) * CarrierFrequency; 
				#elif	PhaseSequence == NegativePhase
				DutyRatio_PhaseA = (ActuationDuration_5 + ActuationDuration_7) * CarrierFrequency;
				DutyRatio_PhaseB =	ActuationDuration_7 * CarrierFrequency;
				DutyRatio_PhaseC = (ActuationDuration_4 + ActuationDuration_5 + ActuationDuration_7) * CarrierFrequency;
				#else
				#error "Phase Sequence Invalid"
				#endif
				SetDutyRatio_PhaseA(DutyRatio_PhaseA);
				SetDutyRatio_PhaseB(DutyRatio_PhaseB);
				SetDutyRatio_PhaseC(DutyRatio_PhaseC);
		break;
	}
	
}

   /**
   * @brief  Floating-point constant power Clark transform
   * @param[in]  voltageA       Voltage of phase A
   * @param[in]  voltageB       Voltage of phase B
   * @param[in]  voltageC       Voltage of phase C
   * @param[out] voltageAlpha  	points to output two-phase orthogonal vector axis alpha
   * @param[out] voltageBeta   	points to output two-phase orthogonal vector axis beta
   */
void ClarkTransform(float voltageA, float voltageB, float voltageC, float voltageAlpha, float voltageBeta)
{
	const float m = 0.81649658f;
	
	voltageAlpha = m * (voltageA - 0.5f * voltageB - 0.5f * voltageC);
	voltageBeta  = m * (0.86602540f * voltageB - 0.86602540f * voltageC);
}

   /**
   * @brief  Floating-point constant power Clark transform
   * @param[in]  voltageA       Voltage of phase A
   * @param[in]  voltageB       Voltage of phase B
   * @param[in]  voltageC       Voltage of phase C
   * @param[out] dVoltage  		points to output two-phase orthogonal vector axis d
   * @param[out] qVoltage   	points to output two-phase orthogonal vector axis q
   */
void ParkTransform(float voltageA, float voltageB, float voltageC, float dVoltage, float qVoltage, float electricalAngle)
{
	const float m = 0.66666667f;
	float sineElectricalAngle_1 = 0;
	float cosineElectricalAngle_1 = 0;
	float sineElectricalAngle_2 = 0;
	float cosineElectricalAngle_2 = 0;
	float sineElectricalAngle_3 = 0;
	float cosineElectricalAngle_3 = 0;
	
	arm_sin_cos_f32(electricalAngle, &sineElectricalAngle_1, &cosineElectricalAngle_1);
	arm_sin_cos_f32((electricalAngle - 2 * PI / 3), &sineElectricalAngle_2, &cosineElectricalAngle_2);
	arm_sin_cos_f32((electricalAngle + 2 * PI / 3), &sineElectricalAngle_3, &cosineElectricalAngle_3);
	
	dVoltage = m * (voltageA * cosineElectricalAngle_1 + voltageB * cosineElectricalAngle_2 + voltageC * cosineElectricalAngle_3);
	qVoltage = - m * (voltageA * sineElectricalAngle_1 + voltageB * sineElectricalAngle_2 + voltageC * sineElectricalAngle_3);
}

/* USER CODE END */

/************************ (C) COPYRIGHT ACTION *****END OF FILE****/
